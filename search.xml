<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据结构课设：多叉路口交通灯管理问题</title>
      <link href="2020/10/12/shu-ju-jie-gou-ke-she-duo-cha-lu-kou-jiao-tong-deng-guan-li-wen-ti/"/>
      <url>2020/10/12/shu-ju-jie-gou-ke-she-duo-cha-lu-kou-jiao-tong-deng-guan-li-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>通常，在十字交叉路口只需设红、绿两色的交通灯便可保持正常的交通秩序，而在多叉路口需设几种颜色的交通灯才能既使车辆相互之间不碰撞，又能达到车辆的最大流通。假设有一个如图(a)所示的五叉路口，其中C和E为单行道。在路口有13条可行的通路，其中有的可以同时通行，如A→B和E→C，而有的不能同时通行，如E→B和A→D。那么，在路口应如何设置交通灯进行车辆的管理呢？<br><img src="https://img-blog.csdnimg.cn/2020021512131335.png" alt="在这里插入图片描述"></p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><h6 id="顶点图解释："><a href="#顶点图解释：" class="headerlink" title="顶点图解释："></a>顶点图解释：</h6><ol><li>圈XY代表从道路X驶向道路Y的通道。</li><li>共有2×C（3，2）+4+3共13条通道。</li><li>若两通道不能同时通行，则将两通道相连。<br><img src="https://img-blog.csdnimg.cn/2020021512155975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h6 id="问题转化为图着色问题"><a href="#问题转化为图着色问题" class="headerlink" title="问题转化为图着色问题"></a>问题转化为图着色问题</h6><p>用最少的颜色对图着色&lt;=&gt;对尽可能多的点着以相同的颜色&lt;=&gt;让尽可能多的通道的车辆可以同时通行=&gt;车流量最大</p><h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>按图里从左到右从上到下的顺序对13个顶点从0~12依次标号，然后按照两顶点之间有边相连值为1，无边相连值为0的规则，得到邻接矩阵，如下：<br>0 0 0 0 1 1 1 0 0 1 0 0 0<br>0 0 0 0 0 1 1 1 0 1 1 0 0<br>0 0 0 0 0 0 0 0 0 1 1 1 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0<br>1 0 0 0 0 0 0 1 0 0 1 0 0<br>1 1 0 0 0 0 1 0 0 0 1 1 0<br>1 1 0 0 0 1 0 0 0 0 1 1 0<br>0 1 0 0 1 0 0 0 0 0 0 1 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0<br>1 1 1 0 0 0 0 0 0 0 0 0 0<br>0 1 1 0 1 1 1 0 0 0 0 0 0<br>0 0 1 0 0 1 1 1 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h5 id="算法1：回溯法（深度优先搜索）"><a href="#算法1：回溯法（深度优先搜索）" class="headerlink" title="算法1：回溯法（深度优先搜索）"></a>算法1：回溯法（深度优先搜索）</h5><p>思路：</p><ol><li>假设符合题意的最小颜色数是m</li><li>则每一个顶点可以涂m种颜色，共m^13种可能（包括合理和不合理的涂色方案）</li><li>采用深度优先搜索算法，找到合理的涂色方案，如果找不到则增加最小颜色数继续查找</li></ol><p><strong><em>该算法一定得到最优解，但时间复杂度高。</em></strong></p><h5 id="算法2：贪婪算法（Welch-Powell算法）"><a href="#算法2：贪婪算法（Welch-Powell算法）" class="headerlink" title="算法2：贪婪算法（Welch Powell算法）"></a>算法2：贪婪算法（Welch Powell算法）</h5><ol><li>将顶点按度数由大到小排列</li><li>对未涂色的度数最大的顶点涂色，并将与该顶点不相连且满足条件的其它顶点涂以相同的颜色</li><li>检查是否存在未涂色的顶点，若有，换一种颜色，重复2），否则，结束算法</li></ol><p><strong><em>该算法是启发式算法，时间复杂度低，但不一定得到最优解。</em></strong></p><h1 id="算法源码"><a href="#算法源码" class="headerlink" title="算法源码"></a>算法源码</h1><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><pre><code>#include &lt;iostream&gt;using namespace std;//颜色类 class Color {    public:        Color(int n,int **a,int *x,int sum);        bool ifOk(int node);        void Dfs(int node);        int n;        //顶点数        int m;        //可用颜色数        int **a;    //邻接矩阵        int *x;        //解向量        int sum;    //可着色方案数};//构造函数 Color::Color(int n,int **a,int *x,int sum){    this-&gt;n=n;    this-&gt;a=a;    this-&gt;x=x;    this-&gt;sum=sum;        }//判断顶点node是否可以涂色 bool Color::ifOk(int node) {    for (int i = 1; i &lt;= n; i++)         if ((a[node-1][i-1] == 1) &amp;&amp; x[node] == x[i])            return false;    return true;}//深度优先搜索 void Color::Dfs(int node) {    //当访问到叶子结点，则找到一种可着色方案 sum++    if (node &gt; n) {        sum++;        //输出该涂色方案         for (int i = 1; i &lt;= n; i++)            cout &lt;&lt; x[i] &lt;&lt; " ";        cout &lt;&lt; endl;    }    //递归     else {        for (int i = 1; i &lt;= m; i++) {            x[node] = i;            if (ifOk(node))                Dfs(node + 1);            x[node] = 0;        }    }}int main() {    //初始化邻接矩阵     int** graph=new int*[13];    for(int i=0;i&lt;13;i++)        graph[i]=new int[13];    for (int i = 0;i &lt; 13;i++)        for (int j = 0;j &lt; 13;j++)            cin &gt;&gt; graph[i][j];    //初始化解向量     int* p=new int[14];    for(int i=0;i&lt;14;i++)        p[i]=0;    //初始化颜色类     Color color(13,graph,p,0);    //涂色     int k=0;    while(true){        k++;        color.m=k;        color.Dfs(1);        if(color.sum!=0)            break;    }    //输出最小颜色数和涂色方案数     cout&lt;&lt;"最小颜色数m为："&lt;&lt;k&lt;&lt;endl;     cout&lt;&lt;"可行的涂色方案数为："&lt;&lt;color.sum;}</code></pre><h3 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h3><pre><code>#include &lt;iostream&gt;#include &lt;queue&gt; using namespace std;struct Node {    int index;    int degree;    int color;};//冒泡排序 void sort(Node* nodes) {    for (int i = 0;i &lt; 13;i++) {        for (int j = 12;j &gt; i;j--) {            if (nodes[j].degree &gt; nodes[j - 1].degree) {                int degree = nodes[j - 1].degree;                int index = nodes[j - 1].index;                nodes[j - 1].degree = nodes[j].degree;                nodes[j - 1].index = nodes[j].index;                nodes[j].degree = degree;                nodes[j].index = index;            }        }    }}//按度数递减顺序输出排序后的顶点 void output(Node* nodes){    queue&lt;int&gt; q0,q1,q2,q3,q4,q5;    queue&lt;int&gt; q[6];     for(int i=0;i&lt;13;i++)        q[nodes[i].degree].push(nodes[i].index);    for(int i=5;i&gt;=0;i--){        cout&lt;&lt;"度数为"&lt;&lt;i&lt;&lt;"的顶点：";        if(q[i].empty())            cout&lt;&lt;"无";        while(!q[i].empty()){            int index=q[i].front( );            cout&lt;&lt;index&lt;&lt;" ";            q[i].pop();            }             cout&lt;&lt;endl;        }}//判断顶点nodes[j]是否可以涂上颜色color bool ifOk(Node* nodes,int** graph,int color,int j){    if(nodes[j].color!=0)        return false;    for(int i=0;i&lt;13;i++)            if(graph[nodes[j].index][i]==1)                for(int m=0;m&lt;13;m++)                    if(nodes[m].index==i)                        if(nodes[m].color==color)                            return false;    return true;} int main() {    //初始化邻接矩阵     int** graph=new int*[13];    for(int i=0;i&lt;13;i++)        graph[i]=new int[13];    //初始化顶点数组，记录13个顶点的索引、度数、颜色        Node* nodes = new Node[13];    for (int i = 0;i &lt; 13;i++) {        int degree = 0;        for (int j = 0;j &lt; 13;j++) {            cin &gt;&gt; graph[i][j];            if (graph[i][j])                degree++;        }        nodes[i].index = i;        nodes[i].degree = degree;        nodes[i].color = 0;    }    //对顶点按度数递减排序     sort(nodes);    //输出排序后的结果     cout&lt;&lt;"按度数由大到小排序后的结果：";     for(int i=0;i&lt;13;i++){        cout&lt;&lt;nodes[i].index&lt;&lt;" ";        if(i==12)            cout&lt;&lt;endl;    }    output(nodes);    //对13个顶点采用贪婪算法进行迭代涂色     int k = 0;    while (true) {        k++;        int i;        for (i = 0;i &lt; 13;i++)             if (nodes[i].color == 0) {                nodes[i].color = k;                break;            }        if (i == 13)            break;        for (int j = 0;j &lt; 13;j++)            if (ifOk(nodes,graph,k,j))                nodes[j].color = k;    }    //输出所需最小颜色数和一种涂色方案     cout &lt;&lt;"所需要的最小颜色数目："&lt;&lt;k-1&lt;&lt;endl;    cout&lt;&lt;"一种涂色方案为："&lt;&lt;endl;    for(int i=1;i&lt;k;i++){        cout&lt;&lt;i&lt;&lt;':';        for(int j=0;j&lt;13;j++)            if(nodes[j].color==i)                cout&lt;&lt;nodes[j].index&lt;&lt;' ';        if(i&lt;k-1)            cout&lt;&lt;endl;    }}</code></pre><h4 id="谢谢阅读，如果有用可否点个赞O-∩-∩-O"><a href="#谢谢阅读，如果有用可否点个赞O-∩-∩-O" class="headerlink" title="谢谢阅读，如果有用可否点个赞O(∩_∩)O"></a>谢谢阅读，如果有用可否点个赞O(∩_∩)O</h4>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>前后端辅助开发工具、网站及IDEA快捷键</title>
      <link href="2020/10/12/qian-hou-duan-fu-zhu-kai-fa-gong-ju-wang-zhan-ji-idea-kuai-jie-jian/"/>
      <url>2020/10/12/qian-hou-duan-fu-zhu-kai-fa-gong-ju-wang-zhan-ji-idea-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h1><p>一些辅助开发工具（下载链接挂到文末）：</p><h2 id="1、尺子，可以测量出电脑任何位置的长宽："><a href="#1、尺子，可以测量出电脑任何位置的长宽：" class="headerlink" title="1、尺子，可以测量出电脑任何位置的长宽："></a>1、尺子，可以测量出电脑任何位置的长宽：</h2><img src="https://gitee.com/guixq/blogImage/raw/master/img/image-20200616202021667.png" alt="image-20200616202021667" style="zoom:80%;"><h2 id="2、取色器，获得任意你看对眼的颜色的代码"><a href="#2、取色器，获得任意你看对眼的颜色的代码" class="headerlink" title="2、取色器，获得任意你看对眼的颜色的代码"></a>2、取色器，获得任意你看对眼的颜色的代码</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjE2MjAzMjE5MjUwLnBuZw?x-oss-process=image/format,png" alt="image-20200616203219250"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjE2MjAzMjQ1MTA3LnBuZw?x-oss-process=image/format,png" alt="image-20200616203245107"></p><h2 id="3、正则表达工具"><a href="#3、正则表达工具" class="headerlink" title="3、正则表达工具"></a>3、正则表达工具</h2><p>注意，随着时代发展，诸如电子邮件、网页链接等等的正则表达式可能会出现变化，因此用该工具生成的正则表达式可能不适合了，就需要您自己去写了！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjIwMjEyNDA4NDgwLnBuZw?x-oss-process=image/format,png" alt="image-20200620212408480"></p><h2 id="4、页面组件位置动态修改"><a href="#4、页面组件位置动态修改" class="headerlink" title="4、页面组件位置动态修改"></a>4、页面组件位置动态修改</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjE2MjAzNzQ4NjI1LnBuZw?x-oss-process=image/format,png" alt="image-20200616203748625"></p><h2 id="5、几个网站"><a href="#5、几个网站" class="headerlink" title="5、几个网站"></a>5、几个网站</h2><p>1、<a href="https://www.grabient.com/">Grabient</a></p><p>调色网站</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjIwMjAyMTIxOTMyLnBuZw?x-oss-process=image/format,png" alt="image-20200620202121932"></p><p>2、<a href="https://en.m.fontke.com/tool/rgbschemes/">RGB配色器</a></p><p>配色网站</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjIwMjAyNzAxNDA2LnBuZw?x-oss-process=image/format,png" alt="image-20200620202701406"></p><p>3、<a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">阿里巴巴矢量图库</a></p><p>图库</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjIwMjExODU4Nzg5LnBuZw?x-oss-process=image/format,png" alt="image-20200620211858789"></p><h1 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h1><h2 id="IDEA快捷键："><a href="#IDEA快捷键：" class="headerlink" title="IDEA快捷键："></a>IDEA快捷键：</h2><p>除了ctrl+c/v/x/z之外一些比较舒服又常用的快捷键：</p><p>ctrl+d：复制当前行到下一行。</p><p>ctrl+c：不选中任何内容的情况下按ctrl+c复制当前行。</p><p>ctrl+y：删除当前行。</p><p>shift+enter：快速开启下一行，无论光标在哪里。</p><p>ctrl+p：光标放在函数头参数列表处使用，可查看函数需要的参数。</p><p>alt+回车：提示代码可进行的操作。</p><p>ctrl+shift+回车：系统自动补全剩余代码。</p><p>ctrl+alt+t：弹出光标所在代码块的可能包围结构。</p><p>ctrl+j：光标选中的代码块可能使用模板。</p><p>ctrl+r：进行查找与替换。</p><p>ctrl+f：仅查找。</p><p>ctrl+shift+↑/↓  或者  alt+shift+↑/↓：上/下 移当前行。</p><p>ctrl+alt+v：自动添加接收函数返回值的变量。</p><p>连按两下shift：想搜啥搜啥。</p><p>ctrl+shift+n：仅搜索文件。</p><p>ctrl+alt+o：管理import的多余引用。</p><p>alt+回车：提示光标所在处可进行的操作。</p><p>ctrl+左键：查看声明。</p><p>alt+鼠标左键选中代码块：可进行部分复制及修改。</p><p>ctrl+e：进行项目中文件的切换。</p><h2 id="Mybatis-plus插件："><a href="#Mybatis-plus插件：" class="headerlink" title="Mybatis-plus插件："></a>Mybatis-plus插件：</h2><p>诸如自动生成代码等等大大提升开发效率，功能多多。</p><h2 id="postman："><a href="#postman：" class="headerlink" title="postman："></a>postman：</h2><p>除了EOLINKER，也可以用一下postman</p><h1 id="辅助开发工具下载链接："><a href="#辅助开发工具下载链接：" class="headerlink" title="辅助开发工具下载链接："></a>辅助开发工具下载链接：</h1><p>链接：<a href="https://pan.baidu.com/s/1x-MK_08OX0EEcY6TNPjaxQ">https://pan.baidu.com/s/1x-MK_08OX0EEcY6TNPjaxQ</a><br>提取码：e58l</p><p><strong>如果帮助到了您，可否点个赞O(∩_∩)O</strong></p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
