<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>使用hexo+github免费搭建个人博客网站教程</title>
      <link href="2020/10/14/shi-yong-hexo-github-mian-fei-da-jian-ge-ren-bo-ke-wang-zhan-jiao-cheng/"/>
      <url>2020/10/14/shi-yong-hexo-github-mian-fei-da-jian-ge-ren-bo-ke-wang-zhan-jiao-cheng/</url>
      
        <content type="html"><![CDATA[<h1 id="建前准备"><a href="#建前准备" class="headerlink" title="建前准备"></a>建前准备</h1><h2 id="1、安装Node-js"><a href="#1、安装Node-js" class="headerlink" title="1、安装Node.js"></a>1、<a href="https://nodejs.org/en/">安装Node.js</a></h2><h2 id="2、安装Git"><a href="#2、安装Git" class="headerlink" title="2、安装Git"></a>2、<a href="https://git-scm.com/">安装Git</a></h2><hr><p>win+r输入cmd回车进入命令行：依次测试如下命令确定是否成功安装</p><pre class=" language-shell"><code class="language-shell">node -vnpm -vgit --version</code></pre><h2 id="3、安装cnpm"><a href="#3、安装cnpm" class="headerlink" title="3、安装cnpm"></a>3、安装cnpm</h2><blockquote><p>npm下载速度太慢，所以我们用淘宝提供的国内镜像cnpm替代</p></blockquote><p>在命令行输入如下代码进行安装</p><pre class=" language-shell"><code class="language-shell">npm install -g cnpm --registry=https://registry.npm.taobao.org</code></pre><p>在命令行输入如下代码测试是否安装成功</p><pre class=" language-shell"><code class="language-shell">cnpm -v</code></pre><h2 id="4、Github账号"><a href="#4、Github账号" class="headerlink" title="4、Github账号"></a>4、Github账号</h2><p>Github官网：<a href="https://github.com/">https://github.com/</a></p><h3 id="设置-user-name-和-user-email-可选"><a href="#设置-user-name-和-user-email-可选" class="headerlink" title="设置 user.name 和 user.email[可选]"></a>设置 user.name 和 user.email[可选]</h3><p>打开Git命令行</p><p>在Git命令行设置user.name和user.email</p><pre class=" language-shell"><code class="language-shell">git config --global user.name "your user-name"git config --global user.email "your user-email"</code></pre><h3 id="配置-SSH-密匙-可选"><a href="#配置-SSH-密匙-可选" class="headerlink" title="配置 SSH 密匙[可选]"></a>配置 SSH 密匙[可选]</h3><pre class=" language-shell"><code class="language-shell">ssh-keygen -t rsa -C user-email/root/.ssh/id_rsa</code></pre><p>然后直接输入回车回车，这时进入到 <code>/root/.ssh/</code> 目录下查看 <code>id_rsa.pub</code> 文件</p><p>复制文件里的所有内容 (所有内容, 一个字符都不要漏) . 然后到 Github 添加 ssh 密匙，点击 <code>New SSH key</code> 按钮进行添加</p><p><img src="https://gitee.com/guixq/blogImage/raw/master/img/hg1.png" alt="1"></p><h1 id="正式开始"><a href="#正式开始" class="headerlink" title="正式开始"></a>正式开始</h1><h2 id="1、新建仓库"><a href="#1、新建仓库" class="headerlink" title="1、新建仓库"></a>1、新建仓库</h2><p>在github新建一个仓库，仓库名为<code>&lt;user-name&gt;.github.io</code>格式，其中<code>&lt;user-name&gt;</code>是你Github的昵称。</p><p>这样做，我们不需要服务器，github免费提供托管服务，我们也不需要购买域名，github同样提供了一个.io的域名。</p><h2 id="2、全局安装hexo"><a href="#2、全局安装hexo" class="headerlink" title="2、全局安装hexo"></a>2、全局安装hexo</h2><pre class=" language-shell"><code class="language-shell">cnpm install -g hexo</code></pre><h2 id="3、初始化项目"><a href="#3、初始化项目" class="headerlink" title="3、初始化项目"></a>3、初始化项目</h2><p>在磁盘里找个地方创建一个文件夹作为你的本地博客资源位置，这个文件夹就是你的项目根目录，然后在此处打开git命令行，运行如下命令，文件夹内就会出现hexo基础配置文件</p><pre class=" language-shell"><code class="language-shell">hexo init</code></pre><h2 id="4、本地查看"><a href="#4、本地查看" class="headerlink" title="4、本地查看"></a>4、本地查看</h2><p>在项目根目录，运行如下命令，可以在本地网址<a href="http://localhost:4000/%E8%AE%BF%E9%97%AE%E4%BD%A0%E7%9A%84%E5%8D%9A%E5%AE%A2">http://localhost:4000/访问你的博客</a></p><pre class=" language-shell"><code class="language-shell">hexo s</code></pre><h2 id="5、部署到github"><a href="#5、部署到github" class="headerlink" title="5、部署到github"></a>5、部署到github</h2><p>在项目根目录找到<code>_congif.yml</code>文件，找到<code>deploy</code>字段并填写完整，填写如下：</p><pre class=" language-yml"><code class="language-yml"># Deployment## Docs: https://hexo.io/docs/deployment.htmldeploy:  type: git  repo: <你的仓库地址> # https://github.com/user-name/user-name.github.io，注意把user-name换成你自己的用户名。  branch: master</code></pre><p>[可选]如果前面配置了SSH，可以把repo字段这样写：</p><pre class=" language-yaml"><code class="language-yaml">git@github.com<span class="token punctuation">:</span>user<span class="token punctuation">-</span>name/user<span class="token punctuation">-</span>name.github.io.git</code></pre><p>这样做的好处是将本地项目部署到github时不用每次输入用户名和密码。</p><p>[部署]</p><p>在项目根目录依次运行如下代码：</p><pre class=" language-shell"><code class="language-shell">hexo clean #简写hexo clhexo ghexo deploy #简写hexo d</code></pre><p>如果部署成功，那么就可以在<a href="https://user-name.github.io/">https://user-name.github.io/</a> 查看效果了</p><p>注：<code>hexo clean &amp;&amp; hexo g &amp;&amp; hexo deploy</code>为部署三件套，我们每次将本地博客内容推送到网络上都需要依次运行这三个命令。</p><p>如果我们修改完本地配置想在本地先查看一下效果，则只需要运行<code>hexo s</code>命令即可。</p><h1 id="主题优化"><a href="#主题优化" class="headerlink" title="主题优化"></a>主题优化</h1><p>不出意外的话，你会在<a href="https://user-name.github.io/">https://user-name.github.io/</a> 这里看到你的博客的效果，但是它很丑有木有！所以我们需要丰富它！</p><h2 id="hexo-theme-matery主题"><a href="#hexo-theme-matery主题" class="headerlink" title="hexo-theme-matery主题"></a>hexo-theme-matery主题</h2><p>目前网上有许多大佬写的优秀的主题，我们可以任选一个应用之，我用的是<a href="https://github.com/blinkfox/hexo-theme-matery">hexo-theme-matery</a>，所以我们以这个主题为例来讲解使用：</p><p>具体基本配置请参考：</p><p><a href="https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md">https://github.com/blinkfox/hexo-theme-matery/blob/develop/README_CN.md</a></p><p>其他一些个性化配置请参考：</p><p><a href="https://blog.csdn.net/cungudafa/article/details/106278206?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160257766819725271706667%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=160257766819725271706667&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v3~pc_rank_v2-1-106278206.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=hexo+matery+%E7%9A%84%E8%83%8C%E6%99%AF%E5%A3%81%E7%BA%B8&amp;spm=1018.2118.3001.4187">hexo（matery）背景、滚动条优化+增加点击跳评论</a></p><p><a href="https://blog.csdn.net/qq_43827595/article/details/104324443?biz_id=102&amp;utm_term=hexo%20matery%20%E4%BD%BF%E7%94%A8%E7%95%99%E8%A8%80%E6%9D%BF&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~sobaiduweb~default-0-104324443&amp;spm=1018.2118.3001.4187">hexo博客matery主题个性化配置</a></p><p>……</p><h1 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jianshu.com/p/390f202c5b0e">5分钟搞定个人博客-hexo</a></p><p><a href="https://blog.csdn.net/wapchief/article/details/54602515?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160247930219195246641248%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160247930219195246641248&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-1-54602515.first_rank_ecpm_v3_pc_rank_v2&amp;utm_term=hexo%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2&amp;spm=1018.2118.3001.4187">使用hexo+github免费搭建个人博客网站超详细教程</a></p><p>……</p>]]></content>
      
      
      <categories>
          
          <category> 网上冲浪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>期末考试回忆版链接</title>
      <link href="2020/10/14/qi-mo-kao-shi-hui-yi-ban-lian-jie/"/>
      <url>2020/10/14/qi-mo-kao-shi-hui-yi-ban-lian-jie/</url>
      
        <content type="html"><![CDATA[<h1 id="大二（2019-2020）"><a href="#大二（2019-2020）" class="headerlink" title="大二（2019-2020）"></a>大二（2019-2020）</h1><h2 id="大二上"><a href="#大二上" class="headerlink" title="大二上"></a>大二上</h2><p><a href="https://blog.csdn.net/weixin_43360801/article/details/103478309">山东大学软件学院Python（考试）——期末考试回忆版</a></p><p><a href="https://blog.csdn.net/weixin_43360801/article/details/103510553">山东大学软件学院概率论与数理统计（考试）——期末考试回忆版</a></p><p><a href="https://blog.csdn.net/weixin_43360801/article/details/103820015">山东大学软件学院计算机组成原理（考试）——期末考试回忆版</a></p><p><a href="https://blog.csdn.net/weixin_43360801/article/details/103904714">山东大学软件学院数据结构（考试）——期末考试回忆版</a></p><h2 id="大二下"><a href="#大二下" class="headerlink" title="大二下"></a>大二下</h2><p><a href="https://blog.csdn.net/weixin_43360801/article/details/108379679">山东大学软件学院操作系统（考试）——期末考试回忆版</a></p><p><a href="https://blog.csdn.net/weixin_43360801/article/details/108411369">山东大学软件学院人工智能导论（考试）——期末考试回忆版</a></p><p><a href="https://blog.csdn.net/weixin_43360801/article/details/108437644">山东大学软件学院算法设计与分析（考试）——期末考试回忆版</a></p><p><a href="https://blog.csdn.net/qq_43451527/article/details/108436903">2020年山东大学李新老师移动互联网开发考试回忆版</a></p>]]></content>
      
      
      <categories>
          
          <category> 转载 </category>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决联想拯救者Y7000安装ubuntu系统wifi无法连接以及关机卡死问题</title>
      <link href="2020/10/14/jie-jue-lian-xiang-zheng-jiu-zhe-y7000-an-zhuang-ubuntu-xi-tong-wifi-wu-fa-lian-jie-yi-ji-guan-ji-qia-si-wen-ti/"/>
      <url>2020/10/14/jie-jue-lian-xiang-zheng-jiu-zhe-y7000-an-zhuang-ubuntu-xi-tong-wifi-wu-fa-lian-jie-yi-ji-guan-ji-qia-si-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="联想拯救者Y7000win10安装双系统ubuntu后爬坑记录"><a href="#联想拯救者Y7000win10安装双系统ubuntu后爬坑记录" class="headerlink" title="联想拯救者Y7000win10安装双系统ubuntu后爬坑记录"></a>联想拯救者Y7000win10安装双系统ubuntu后爬坑记录</h1><h5 id="具体ubuntu安装过程请参照其它教程，本文主要介绍解决wifi无法连接和关机卡死问题的方法"><a href="#具体ubuntu安装过程请参照其它教程，本文主要介绍解决wifi无法连接和关机卡死问题的方法" class="headerlink" title="具体ubuntu安装过程请参照其它教程，本文主要介绍解决wifi无法连接和关机卡死问题的方法"></a>具体ubuntu安装过程请参照其它教程，本文主要介绍解决wifi无法连接和关机卡死问题的方法</h5><h2 id="1、解决wifi无法连接问题："><a href="#1、解决wifi无法连接问题：" class="headerlink" title="1、解决wifi无法连接问题："></a>1、解决wifi无法连接问题：</h2><p>首先我们要明白问题所在，之所以wifi无法连接，是因为联想自己的驱动和ubuntu的驱动存在冲突。<br>在命令行中输入指令 <code>sudo rfkill list all </code>可以看到现在启动的驱动，其中ideapad版本是联想自带的驱动，它和ubuntu默认的驱动冲突,所以我们只要让ubuntu系统启动后不要启动ideapad这个驱动即可解决wifi无法连接的问题。</p><p>所以在命令行中输入：<code>sudo modprobe -r ideapad_laptop</code>即可关闭该驱动，但由于该命令只在本次开机有效，所以每次开机都要重新输入一遍命令，很麻烦，所以可以考虑将该命令写入系统文件，使得每次开机系统自动执行该命令。<br>方法为：<br><strong>18.04版本之前</strong>的系统文件为rx.local<br>通过代码<code>sudo nano /etc/rx.local</code>打开文件，然后在文件结尾的exit 0上一行添加命令<br><code>echo "123" |sudo modprobe -r ideapad_laptop</code>保存退出即可。<br><strong>18.04版本</strong>ubuntu18.04不再使用 inited 管理系统，改用 systemd，已经没有了/etc/rx.local文件，如果还想要使用这种方法禁用ideapad驱动启动，可参考<a href="https://blog.csdn.net/qq_41782149/article/details/89001226">https://blog.csdn.net/qq_41782149/article/details/89001226</a>这篇博客自己创建/etc/rx.local文件。<br>所以<strong>18.04版本更方便的一种解决方案</strong>是直接将ideapad该驱动模块列入黑名单来禁用该模块。具体方式如下：<br>1、 为你的个人黑名单创建一个文件：<code>sudo vim /etc/modprobe.d/myownblacklist.conf</code><br>2、 在该文件里添加ideapad模块名单：<code>ideapad_laptop</code><br>3、保存退出，重新启动，大功告成！<br><a href="https://www.cnblogs.com/dccmmtop/p/7470087.html">这里是该方法的参考链接</a></p><h2 id="2、解决关机卡死问题："><a href="#2、解决关机卡死问题：" class="headerlink" title="2、解决关机卡死问题："></a>2、解决关机卡死问题：</h2><p>OK，解决wifi无法连接后我们再解决关机卡死问题：<br>首先，关机卡死原因：ubuntu系统不支持你的显卡。<br>所以我们要下载驱动支持。<br>第一步：点击最左上角的活动按钮，搜索如图：<img src="https://img-blog.csdnimg.cn/20191130194841377.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">打开如图：<br><img src="https://img-blog.csdnimg.cn/20191130195019462.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>更改“下载自：”处的网址为阿里云的网址，然后点击关闭会出现如下提示：<br><img src="https://img-blog.csdnimg.cn/20191130210905717.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>选择重新载入，等待载入完毕之后再打开软件和更新，选择附加驱动——&gt;带有专有的NVIDIA驱动——&gt;应用更改——&gt;等待安装完成后即可解决关机卡死问题。<br>如图：<br><img src="https://img-blog.csdnimg.cn/2019113021111178.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br><a href="https://blog.csdn.net/weixin_44585583/article/details/90704452">这里是该方法的参考链接</a></p>]]></content>
      
      
      <categories>
          
          <category> 网上冲浪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分搜索算法（转载自知乎大佬）</title>
      <link href="2020/10/14/er-fen-sou-suo-suan-fa-zhuan-zai-zi-zhi-hu-da-lao/"/>
      <url>2020/10/14/er-fen-sou-suo-suan-fa-zhuan-zai-zi-zhi-hu-da-lao/</url>
      
        <content type="html"><![CDATA[<h2 id="二分搜索算法及应用"><a href="#二分搜索算法及应用" class="headerlink" title="二分搜索算法及应用"></a>二分搜索算法及应用</h2><p><a href="https://www.zhihu.com/question/36132386">这里是本算法的完全参考链接</a><span class="github-emoji"><span>◀</span><img src="https://github.githubassets.com/images/icons/emoji/unicode/25c0.png?v8" aria-hidden="true" onerror="this.parent.classList.add('github-emoji-fallback')"></span></p><h3 id="什么是二分搜索算法"><a href="#什么是二分搜索算法" class="headerlink" title="什么是二分搜索算法"></a>什么是二分搜索算法</h3><p><strong>二分搜索</strong>（binary search）也称<strong>折半搜索</strong>（half-interval search）、<strong>对数搜索</strong>（logarithmic search），是一种在有序数组中查找某一特定元素的搜索算法。</p><p>搜索过程从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果某一特定元素大于或者小于中间元素，则在数组大于或小于中间元素的那一半中查找，而且跟开始一样从中间元素开始比较。如果在某一步骤数组为空，则代表找不到。这种搜索算法每一次比较都使搜索范围缩小一半。</p><blockquote><h3 id="学习算法的三个步骤"><a href="#学习算法的三个步骤" class="headerlink" title="==学习算法的三个步骤=="></a>==<em>学习算法的三个步骤</em>==</h3><ol><li>问题的形式化描述（问题是什么？输入输出是什么？）</li><li>算法设计</li><li>算法分析（正确性及复杂度分析）</li></ol></blockquote><h3 id="二分搜索算法的各种情况"><a href="#二分搜索算法的各种情况" class="headerlink" title="二分搜索算法的各种情况"></a>二分搜索算法的各种情况</h3><blockquote><p>我们接下来讲的是==广义二分搜索算法==，我们讲这个的目的是想要尽可能用一种写法来基本普适各种情况，以便我们以后能够正确地记住并根据具体情况修改及使用该算法。</p></blockquote><ul><li>求下界，即找满足<code>x &gt;= value</code>或<code>x &gt; value</code>条件的**最小<code>x</code>**的位置</li><li>求<em>上界</em>，即找满足<code>x &lt;= value</code>或<code>x &lt; value</code>条件的**最大<code>x</code>**的位置</li></ul><p>如果继续细分，还可以分为对非降序和非升序的数组进行求解。</p><p>十六种？</p><h2 id="以寻找非降序数组内第一个不小于value值的最小x位置为例来说明算法："><a href="#以寻找非降序数组内第一个不小于value值的最小x位置为例来说明算法：" class="headerlink" title="以寻找非降序数组内第一个不小于value值的最小x位置为例来说明算法："></a>以寻找非降序数组内第一个不小于value值的最小x位置为例来说明算法：</h2><h3 id="二分搜索算法的实现思想"><a href="#二分搜索算法的实现思想" class="headerlink" title="二分搜索算法的实现思想"></a>二分搜索算法的实现思想</h3><p>伪代码：</p><pre class=" language-c++"><code class="language-c++">//返回[first，last)内第一个不小于value值的位置//array是非降序数组BINARYSEARCH(array，first，last，value){    while （first < last）:     //搜索区间[first, last)不为空        mid = first + (last - first) /2  //防滥出        if (array[mid] < value)             first = mid + 1        else    //array[mid] >= value            last = mid    return first     //last也行，因为[first， last)为空的时候它们重合}</code></pre><h3 id="二分搜索算法相关分析"><a href="#二分搜索算法相关分析" class="headerlink" title="二分搜索算法相关分析"></a>二分搜索算法相关分析</h3><h4 id="正确性证明"><a href="#正确性证明" class="headerlink" title="正确性证明"></a>正确性证明</h4><h5 id="1、为什么使用左闭右开的参数"><a href="#1、为什么使用左闭右开的参数" class="headerlink" title="1、为什么使用左闭右开的参数"></a>1、为什么使用左闭右开的参数</h5><p>一切始于图灵奖得主==Dijkstra==（据说他不用纸笔只花了二十分钟就发明了著名的==迪杰斯特拉算法==），其大致思路如下：</p><p>假设有一个长度为4的数组,用整数边界的区间表示它的下标0,1,2,3,有四种写法:</p><pre><code>a)    0≤i&lt;4b)    -1&lt;i≤3c)    0≤i≤3d)    -1&lt;i&lt;4</code></pre><p>显然左边不闭的话-1 太丑了，所以只考虑a)和c)，然后怎么取舍呢?<br>现在假设该数组长度慢慢减小到0，右边界减小，此时它的index范围是空集$\emptyset$,整数边界的区<br>间的四种写法变成了:</p><pre><code>a)    0≤i&lt;0b)    -1&lt;i≤-1c)    0≤i≤-1d)    -1&lt;i&lt;0</code></pre><p>现在只有a)不会出现负数了。看来左闭右开的a)是唯一种不反人类的写法!它还有一些个<br>好处:<br>1.区间两端值的差，如[0, 4) 中的4-0=4,正好是区间或数组的长度<br>2.刚好相邻的区间，如[0, 2)和[2, 4)，中间值(即2)相同,一眼就可以看出来</p><h5 id="2、如何取中点"><a href="#2、如何取中点" class="headerlink" title="2、如何取中点"></a>2、如何取中点</h5><p>如果用<code>mid = (first + last)/2</code>计算中点，在C++、JAVA等语言里可能会出现溢出现象。</p><p>解决方案就是将其改写成<code>mid = first + (last - first)/2</code>的写法，其中<code>lenth = last - first</code>为区间长度。</p><p>此外，中点的选择并不唯一，</p><p>1、上位中位数：<code>upperMid = first + length/2</code></p><p>2、下位中位数：<code>lowerMid = first + (length - 1)/2</code></p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNTIwMDgyMTQ2NTY0LnBuZw?x-oss-process=image/format,png" alt="image-20200520082146564"></p><p>由于下位中位数还需要减一，用起来怪麻烦，所以我们选择使用上位中位数。</p><h5 id="3、while里的循环不变量-loop-invariants"><a href="#3、while里的循环不变量-loop-invariants" class="headerlink" title="3、while里的循环不变量 - loop invariants"></a>3、while里的循环不变量 - loop invariants</h5><p>代码进入while循环里面时一定成立的条件：</p><ol><li>搜索范围<code>[first, last)</code>不为空，即<code>first &lt; last</code> ；</li><li>搜索范围左侧所有元素都小于value（若存在），搜索范围右侧所有元素都大于等于value（若存在）。</li></ol><h5 id="4、-本算法中，当-first-last-为空的时候first与last重合"><a href="#4、-本算法中，当-first-last-为空的时候first与last重合" class="headerlink" title="4、 本算法中，当[first,last)为空的时候first与last重合"></a>4、 本算法中，当[first,last)为空的时候first与last重合</h5><p>综合1、2、3，当[first,last)为空的时候first与last重合且该值即为第一个不小于value值的位置</p><p>为什么：因为算法的最终一定会收敛到区间first=last的结束，在该最终步的上一步的while循环里，根据循环不变量，我们再分析该区间长度为1的区间缩小策略，就可以得出结论。</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNTIwMDkxMTU3MTMzLnBuZw?x-oss-process=image/format,png" alt="image-20200520091157133"></p><p>最好，我们需要说明，该算法其实没必要必须是非降序，只需要value值两侧的部分是数组的一个划分就可以满足循环不变量，说人话就是我们要找的元素的左侧的元素都小于value值，右侧元素都大于等于value值即可。</p><h5 id="5、举例"><a href="#5、举例" class="headerlink" title="5、举例"></a>5、举例</h5><h5 id="6、-其他情况算法变化"><a href="#6、-其他情况算法变化" class="headerlink" title="6、 其他情况算法变化"></a>6、 其他情况算法变化</h5><p>==这个广义的二分算法，只要value是这个数组的一个划分就可以了。==</p><p>==对于非降序数组==</p><ol><li>找满足<code>x &gt; value</code>条件的**最小<code>x</code>**的位置</li></ol><p>根据以上分析，将if条件改为小于等于即可</p><ol start="2"><li>找满足<code>x &lt;= value</code>条件的**最大<code>x</code>**的位置</li></ol><p>情况1得到的位置再减一即可</p><ol start="3"><li>找满足<code>x &lt; value</code>条件的**最大<code>x</code>**的位置</li></ol><p>我们讨论的<code>寻找非降序数组内第一个不小于value值的位置</code>的情况得到的位置再减一即可。</p><p>……</p><p>==对于非增序数组==</p><ol><li>通过对while循环最后一步的分析修改红框里箭头处的三个条件</li></ol><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNTIwMjEwMTMyNjcyLnBuZw?x-oss-process=image/format,png" alt="image-20200520210132672"></p><ol start="2"><li>将数组反序后求非降序数组的镜像位置之后再求出原问题的位置</li></ol><p><strong>分析一个例子：</strong></p><p>求非增序数组<code>x &gt;= value</code>的x的最大位置（给定value为3）</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNTIwMjAyNjUyMTE1LnBuZw?x-oss-process=image/format,png" alt="image-20200520202652115"></p><p>分析while循环的最后一步，考虑如何设置if条件和返回值：</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNTIwMjEwODEyMDU3LnBuZw?x-oss-process=image/format,png" alt="image-20200520210812057"></p><p>由分析可得相应算法：</p><pre class=" language-c++"><code class="language-c++">//返回[first，last)内第一个不小于value值的位置//array是非降序数组BINARYSEARCH(array，first，last，value){    while （first < last）:     //搜索区间[first, last)不为空        mid = first + (last - first) /2  //防滥出        if (array[mid] >= value)             first = mid + 1        else    //array[mid] < value            last = mid    return first-1     //last-1也行，因为[first， last)为空的时候它们重合}</code></pre><p>……</p><h4 id="时间复杂度分析"><a href="#时间复杂度分析" class="headerlink" title="时间复杂度分析"></a>时间复杂度分析</h4><p>O(logn)</p><h3 id="二分搜索算法的相关应用"><a href="#二分搜索算法的相关应用" class="headerlink" title="二分搜索算法的相关应用"></a>二分搜索算法的相关应用</h3><p><a href="https://leetcode-cn.com/problems/binary-search/">一道力扣简单题，二分查找</a></p>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决Github图片资源无法访问的问题</title>
      <link href="2020/10/13/jie-jue-github-tu-pian-zi-yuan-wu-fa-fang-wen-de-wen-ti/"/>
      <url>2020/10/13/jie-jue-github-tu-pian-zi-yuan-wu-fa-fang-wen-de-wen-ti/</url>
      
        <content type="html"><![CDATA[<h3 id="修改C-Windows-System32-drivers-etc下的hosts文件"><a href="#修改C-Windows-System32-drivers-etc下的hosts文件" class="headerlink" title="修改C:\Windows\System32\drivers\etc下的hosts文件"></a>修改C:\Windows\System32\drivers\etc下的hosts文件</h3><blockquote><h3 id="良心教程！"><a href="#良心教程！" class="headerlink" title="良心教程！"></a><strong>良心教程！</strong></h3><p><strong>修改思路：</strong><br><strong>第一步，查找域名ip地址：</strong><br>1、 在未显示图片的页面右键审查元素</p></blockquote><p>2、<br>    <img src="https://img-blog.csdnimg.cn/20200703132527332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述">3、<br><img src="https://img-blog.csdnimg.cn/20200703132624525.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>4、找到该图片的域名：user-images.githubusercontent.com<br>5、来<a href="https://www.ipaddress.com/">这里</a>查询该域名的ip地址<br><strong>第二步：修改hosts文件：</strong><br>修改方式举例：<br>比如我在2020/7/3号查到的域名如下：<br><img src="https://img-blog.csdnimg.cn/20200703133129926.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>于是在hosts文件末尾添加如下代码：<br><img src="https://img-blog.csdnimg.cn/20200703133401510.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"><br>注意该代码分为两部分，<strong>199.232.68.133</strong>和<strong>user-images.githubusercontent.com</strong><br>一般而言，<strong>199.232.68.133</strong>在不同时间段内会发生变化的，因此，这就是为什么你们去复制大部分博文给的现成的代码来修改hosts但是无效的原因，这里，我不给出现成的代码，我会给出代码模板，大家可以根据上述步骤来自行修改hosts文件。</p><pre><code>199.232.68.133 raw.githubusercontent.com199.232.68.133 camo.githubusercontent.com199.232.68.133 gist.githubusercontent.com199.232.68.133 cloud.githubusercontent.com199.232.68.133 assets-cdn.githubusercontent.com199.232.68.133 user-images.githubusercontent.com199.232.68.133 avatars0.githubusercontent.com199.232.68.133 avatars1.githubusercontent.com199.232.68.133 avatars2.githubusercontent.com199.232.68.133 avatars3.githubusercontent.com199.232.68.133 avatars4.githubusercontent.com199.232.68.133 avatars5.githubusercontent.com199.232.68.133 avatars6.githubusercontent.com199.232.68.133 avatars7.githubusercontent.com199.232.68.133 avatars8.githubusercontent.com</code></pre><p><img src="https://img-blog.csdnimg.cn/20200703134758127.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></p>]]></content>
      
      
      <categories>
          
          <category> 网上冲浪 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构课设：多叉路口交通灯管理问题</title>
      <link href="2020/10/12/shu-ju-jie-gou-ke-she-duo-cha-lu-kou-jiao-tong-deng-guan-li-wen-ti/"/>
      <url>2020/10/12/shu-ju-jie-gou-ke-she-duo-cha-lu-kou-jiao-tong-deng-guan-li-wen-ti/</url>
      
        <content type="html"><![CDATA[<h1 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h1><p>通常，在十字交叉路口只需设红、绿两色的交通灯便可保持正常的交通秩序，而在多叉路口需设几种颜色的交通灯才能既使车辆相互之间不碰撞，又能达到车辆的最大流通。假设有一个如图(a)所示的五叉路口，其中C和E为单行道。在路口有13条可行的通路，其中有的可以同时通行，如A→B和E→C，而有的不能同时通行，如E→B和A→D。那么，在路口应如何设置交通灯进行车辆的管理呢？<br><img src="https://img-blog.csdnimg.cn/2020021512131335.png" alt="在这里插入图片描述"></p><h1 id="思路分析"><a href="#思路分析" class="headerlink" title="思路分析"></a>思路分析</h1><h6 id="顶点图解释："><a href="#顶点图解释：" class="headerlink" title="顶点图解释："></a>顶点图解释：</h6><ol><li>圈XY代表从道路X驶向道路Y的通道。</li><li>共有2×C（3，2）+4+3共13条通道。</li><li>若两通道不能同时通行，则将两通道相连。<br><img src="https://img-blog.csdnimg.cn/2020021512155975.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQzNDUxNTI3,size_16,color_FFFFFF,t_70" alt="在这里插入图片描述"></li></ol><h6 id="问题转化为图着色问题"><a href="#问题转化为图着色问题" class="headerlink" title="问题转化为图着色问题"></a>问题转化为图着色问题</h6><p>用最少的颜色对图着色&lt;=&gt;对尽可能多的点着以相同的颜色&lt;=&gt;让尽可能多的通道的车辆可以同时通行=&gt;车流量最大</p><h6 id="邻接矩阵"><a href="#邻接矩阵" class="headerlink" title="邻接矩阵"></a>邻接矩阵</h6><p>按图里从左到右从上到下的顺序对13个顶点从0~12依次标号，然后按照两顶点之间有边相连值为1，无边相连值为0的规则，得到邻接矩阵，如下：<br>0 0 0 0 1 1 1 0 0 1 0 0 0<br>0 0 0 0 0 1 1 1 0 1 1 0 0<br>0 0 0 0 0 0 0 0 0 1 1 1 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0<br>1 0 0 0 0 0 0 1 0 0 1 0 0<br>1 1 0 0 0 0 1 0 0 0 1 1 0<br>1 1 0 0 0 1 0 0 0 0 1 1 0<br>0 1 0 0 1 0 0 0 0 0 0 1 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0<br>1 1 1 0 0 0 0 0 0 0 0 0 0<br>0 1 1 0 1 1 1 0 0 0 0 0 0<br>0 0 1 0 0 1 1 1 0 0 0 0 0<br>0 0 0 0 0 0 0 0 0 0 0 0 0</p><h1 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h1><h5 id="算法1：回溯法（深度优先搜索）"><a href="#算法1：回溯法（深度优先搜索）" class="headerlink" title="算法1：回溯法（深度优先搜索）"></a>算法1：回溯法（深度优先搜索）</h5><p>思路：</p><ol><li>假设符合题意的最小颜色数是m</li><li>则每一个顶点可以涂m种颜色，共m^13种可能（包括合理和不合理的涂色方案）</li><li>采用深度优先搜索算法，找到合理的涂色方案，如果找不到则增加最小颜色数继续查找</li></ol><p><strong><em>该算法一定得到最优解，但时间复杂度高。</em></strong></p><h5 id="算法2：贪婪算法（Welch-Powell算法）"><a href="#算法2：贪婪算法（Welch-Powell算法）" class="headerlink" title="算法2：贪婪算法（Welch Powell算法）"></a>算法2：贪婪算法（Welch Powell算法）</h5><ol><li>将顶点按度数由大到小排列</li><li>对未涂色的度数最大的顶点涂色，并将与该顶点不相连且满足条件的其它顶点涂以相同的颜色</li><li>检查是否存在未涂色的顶点，若有，换一种颜色，重复2），否则，结束算法</li></ol><p><strong><em>该算法是启发式算法，时间复杂度低，但不一定得到最优解。</em></strong></p><h1 id="算法源码"><a href="#算法源码" class="headerlink" title="算法源码"></a>算法源码</h1><h3 id="算法1"><a href="#算法1" class="headerlink" title="算法1"></a>算法1</h3><pre><code>#include &lt;iostream&gt;using namespace std;//颜色类 class Color {    public:        Color(int n,int **a,int *x,int sum);        bool ifOk(int node);        void Dfs(int node);        int n;        //顶点数        int m;        //可用颜色数        int **a;    //邻接矩阵        int *x;        //解向量        int sum;    //可着色方案数};//构造函数 Color::Color(int n,int **a,int *x,int sum){    this-&gt;n=n;    this-&gt;a=a;    this-&gt;x=x;    this-&gt;sum=sum;        }//判断顶点node是否可以涂色 bool Color::ifOk(int node) {    for (int i = 1; i &lt;= n; i++)         if ((a[node-1][i-1] == 1) &amp;&amp; x[node] == x[i])            return false;    return true;}//深度优先搜索 void Color::Dfs(int node) {    //当访问到叶子结点，则找到一种可着色方案 sum++    if (node &gt; n) {        sum++;        //输出该涂色方案         for (int i = 1; i &lt;= n; i++)            cout &lt;&lt; x[i] &lt;&lt; " ";        cout &lt;&lt; endl;    }    //递归     else {        for (int i = 1; i &lt;= m; i++) {            x[node] = i;            if (ifOk(node))                Dfs(node + 1);            x[node] = 0;        }    }}int main() {    //初始化邻接矩阵     int** graph=new int*[13];    for(int i=0;i&lt;13;i++)        graph[i]=new int[13];    for (int i = 0;i &lt; 13;i++)        for (int j = 0;j &lt; 13;j++)            cin &gt;&gt; graph[i][j];    //初始化解向量     int* p=new int[14];    for(int i=0;i&lt;14;i++)        p[i]=0;    //初始化颜色类     Color color(13,graph,p,0);    //涂色     int k=0;    while(true){        k++;        color.m=k;        color.Dfs(1);        if(color.sum!=0)            break;    }    //输出最小颜色数和涂色方案数     cout&lt;&lt;"最小颜色数m为："&lt;&lt;k&lt;&lt;endl;     cout&lt;&lt;"可行的涂色方案数为："&lt;&lt;color.sum;}</code></pre><h3 id="算法2"><a href="#算法2" class="headerlink" title="算法2"></a>算法2</h3><pre><code>#include &lt;iostream&gt;#include &lt;queue&gt; using namespace std;struct Node {    int index;    int degree;    int color;};//冒泡排序 void sort(Node* nodes) {    for (int i = 0;i &lt; 13;i++) {        for (int j = 12;j &gt; i;j--) {            if (nodes[j].degree &gt; nodes[j - 1].degree) {                int degree = nodes[j - 1].degree;                int index = nodes[j - 1].index;                nodes[j - 1].degree = nodes[j].degree;                nodes[j - 1].index = nodes[j].index;                nodes[j].degree = degree;                nodes[j].index = index;            }        }    }}//按度数递减顺序输出排序后的顶点 void output(Node* nodes){    queue&lt;int&gt; q0,q1,q2,q3,q4,q5;    queue&lt;int&gt; q[6];     for(int i=0;i&lt;13;i++)        q[nodes[i].degree].push(nodes[i].index);    for(int i=5;i&gt;=0;i--){        cout&lt;&lt;"度数为"&lt;&lt;i&lt;&lt;"的顶点：";        if(q[i].empty())            cout&lt;&lt;"无";        while(!q[i].empty()){            int index=q[i].front( );            cout&lt;&lt;index&lt;&lt;" ";            q[i].pop();            }             cout&lt;&lt;endl;        }}//判断顶点nodes[j]是否可以涂上颜色color bool ifOk(Node* nodes,int** graph,int color,int j){    if(nodes[j].color!=0)        return false;    for(int i=0;i&lt;13;i++)            if(graph[nodes[j].index][i]==1)                for(int m=0;m&lt;13;m++)                    if(nodes[m].index==i)                        if(nodes[m].color==color)                            return false;    return true;} int main() {    //初始化邻接矩阵     int** graph=new int*[13];    for(int i=0;i&lt;13;i++)        graph[i]=new int[13];    //初始化顶点数组，记录13个顶点的索引、度数、颜色        Node* nodes = new Node[13];    for (int i = 0;i &lt; 13;i++) {        int degree = 0;        for (int j = 0;j &lt; 13;j++) {            cin &gt;&gt; graph[i][j];            if (graph[i][j])                degree++;        }        nodes[i].index = i;        nodes[i].degree = degree;        nodes[i].color = 0;    }    //对顶点按度数递减排序     sort(nodes);    //输出排序后的结果     cout&lt;&lt;"按度数由大到小排序后的结果：";     for(int i=0;i&lt;13;i++){        cout&lt;&lt;nodes[i].index&lt;&lt;" ";        if(i==12)            cout&lt;&lt;endl;    }    output(nodes);    //对13个顶点采用贪婪算法进行迭代涂色     int k = 0;    while (true) {        k++;        int i;        for (i = 0;i &lt; 13;i++)             if (nodes[i].color == 0) {                nodes[i].color = k;                break;            }        if (i == 13)            break;        for (int j = 0;j &lt; 13;j++)            if (ifOk(nodes,graph,k,j))                nodes[j].color = k;    }    //输出所需最小颜色数和一种涂色方案     cout &lt;&lt;"所需要的最小颜色数目："&lt;&lt;k-1&lt;&lt;endl;    cout&lt;&lt;"一种涂色方案为："&lt;&lt;endl;    for(int i=1;i&lt;k;i++){        cout&lt;&lt;i&lt;&lt;':';        for(int j=0;j&lt;13;j++)            if(nodes[j].color==i)                cout&lt;&lt;nodes[j].index&lt;&lt;' ';        if(i&lt;k-1)            cout&lt;&lt;endl;    }}</code></pre><h4 id="谢谢阅读，如果有用可否点个赞O-∩-∩-O"><a href="#谢谢阅读，如果有用可否点个赞O-∩-∩-O" class="headerlink" title="谢谢阅读，如果有用可否点个赞O(∩_∩)O"></a>谢谢阅读，如果有用可否点个赞O(∩_∩)O</h4>]]></content>
      
      
      <categories>
          
          <category> 专业课 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> algorithm </tag>
            
            <tag> data structure </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>前后端辅助开发工具、网站及IDEA快捷键</title>
      <link href="2020/10/12/qian-hou-duan-fu-zhu-kai-fa-gong-ju-wang-zhan-ji-idea-kuai-jie-jian/"/>
      <url>2020/10/12/qian-hou-duan-fu-zhu-kai-fa-gong-ju-wang-zhan-ji-idea-kuai-jie-jian/</url>
      
        <content type="html"><![CDATA[<h1 id="前端："><a href="#前端：" class="headerlink" title="前端："></a>前端：</h1><p>一些辅助开发工具（下载链接挂到文末）：</p><h2 id="1、尺子，可以测量出电脑任何位置的长宽："><a href="#1、尺子，可以测量出电脑任何位置的长宽：" class="headerlink" title="1、尺子，可以测量出电脑任何位置的长宽："></a>1、尺子，可以测量出电脑任何位置的长宽：</h2><img src="https://gitee.com/guixq/blogImage/raw/master/img/image-20200616202021667.png" alt="image-20200616202021667" style="zoom:80%;"><h2 id="2、取色器，获得任意你看对眼的颜色的代码"><a href="#2、取色器，获得任意你看对眼的颜色的代码" class="headerlink" title="2、取色器，获得任意你看对眼的颜色的代码"></a>2、取色器，获得任意你看对眼的颜色的代码</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjE2MjAzMjE5MjUwLnBuZw?x-oss-process=image/format,png" alt="image-20200616203219250"><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjE2MjAzMjQ1MTA3LnBuZw?x-oss-process=image/format,png" alt="image-20200616203245107"></p><h2 id="3、正则表达工具"><a href="#3、正则表达工具" class="headerlink" title="3、正则表达工具"></a>3、正则表达工具</h2><p>注意，随着时代发展，诸如电子邮件、网页链接等等的正则表达式可能会出现变化，因此用该工具生成的正则表达式可能不适合了，就需要您自己去写了！</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjIwMjEyNDA4NDgwLnBuZw?x-oss-process=image/format,png" alt="image-20200620212408480"></p><h2 id="4、页面组件位置动态修改"><a href="#4、页面组件位置动态修改" class="headerlink" title="4、页面组件位置动态修改"></a>4、页面组件位置动态修改</h2><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjE2MjAzNzQ4NjI1LnBuZw?x-oss-process=image/format,png" alt="image-20200616203748625"></p><h2 id="5、几个网站"><a href="#5、几个网站" class="headerlink" title="5、几个网站"></a>5、几个网站</h2><p>1、<a href="https://www.grabient.com/">Grabient</a></p><p>调色网站</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjIwMjAyMTIxOTMyLnBuZw?x-oss-process=image/format,png" alt="image-20200620202121932"></p><p>2、<a href="https://en.m.fontke.com/tool/rgbschemes/">RGB配色器</a></p><p>配色网站</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjIwMjAyNzAxNDA2LnBuZw?x-oss-process=image/format,png" alt="image-20200620202701406"></p><p>3、<a href="https://www.iconfont.cn/home/index?spm=a313x.7781069.1998910419.2">阿里巴巴矢量图库</a></p><p>图库</p><p><img src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9naXRlZS5jb20vZ3VpeHEvYmxvZ0ltYWdlL3Jhdy9tYXN0ZXIvaW1nL2ltYWdlLTIwMjAwNjIwMjExODU4Nzg5LnBuZw?x-oss-process=image/format,png" alt="image-20200620211858789"></p><h1 id="后端："><a href="#后端：" class="headerlink" title="后端："></a>后端：</h1><h2 id="IDEA快捷键："><a href="#IDEA快捷键：" class="headerlink" title="IDEA快捷键："></a>IDEA快捷键：</h2><p>除了ctrl+c/v/x/z之外一些比较舒服又常用的快捷键：</p><p>ctrl+d：复制当前行到下一行。</p><p>ctrl+c：不选中任何内容的情况下按ctrl+c复制当前行。</p><p>ctrl+y：删除当前行。</p><p>shift+enter：快速开启下一行，无论光标在哪里。</p><p>ctrl+p：光标放在函数头参数列表处使用，可查看函数需要的参数。</p><p>alt+回车：提示代码可进行的操作。</p><p>ctrl+shift+回车：系统自动补全剩余代码。</p><p>ctrl+alt+t：弹出光标所在代码块的可能包围结构。</p><p>ctrl+j：光标选中的代码块可能使用模板。</p><p>ctrl+r：进行查找与替换。</p><p>ctrl+f：仅查找。</p><p>ctrl+shift+↑/↓  或者  alt+shift+↑/↓：上/下 移当前行。</p><p>ctrl+alt+v：自动添加接收函数返回值的变量。</p><p>连按两下shift：想搜啥搜啥。</p><p>ctrl+shift+n：仅搜索文件。</p><p>ctrl+alt+o：管理import的多余引用。</p><p>alt+回车：提示光标所在处可进行的操作。</p><p>ctrl+左键：查看声明。</p><p>alt+鼠标左键选中代码块：可进行部分复制及修改。</p><p>ctrl+e：进行项目中文件的切换。</p><h2 id="Mybatis-plus插件："><a href="#Mybatis-plus插件：" class="headerlink" title="Mybatis-plus插件："></a>Mybatis-plus插件：</h2><p>诸如自动生成代码等等大大提升开发效率，功能多多。</p><h2 id="postman："><a href="#postman：" class="headerlink" title="postman："></a>postman：</h2><p>除了EOLINKER，也可以用一下postman</p><h1 id="辅助开发工具下载链接："><a href="#辅助开发工具下载链接：" class="headerlink" title="辅助开发工具下载链接："></a>辅助开发工具下载链接：</h1><p>链接：<a href="https://pan.baidu.com/s/1x-MK_08OX0EEcY6TNPjaxQ">https://pan.baidu.com/s/1x-MK_08OX0EEcY6TNPjaxQ</a><br>提取码：e58l</p><p><strong>如果帮助到了您，可否点个赞O(∩_∩)O</strong></p>]]></content>
      
      
      <categories>
          
          <category> 后端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> tips </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
